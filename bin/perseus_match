#! /usr/bin/ruby

require 'optparse'
require 'benchmark'
require 'yaml'
require 'jcode'

require 'rubygems'
require 'nuggets/enumerable/minmax'
require 'nuggets/numeric/duration'

$: << File.join(File.dirname(__FILE__), '..', 'lib')

require 'perseus_match'

USAGE = "Usage: #{$0} [-h|--help] [options] <file>"
abort USAGE if ARGV.empty?

options = {
  :config      => nil,
  :threshold   => 0,
  :minimal     => false,
  :sort        => false,
  :lingo       => false,
  :stats       => false,
  :check       => false,
  :failed_only => false,
  :align       => false
}

OptionParser.new { |opts|
  opts.banner = USAGE

  opts.separator ''
  opts.separator 'Options:'

  opts.on('-c', '--config YAML', 'Config file in YAML format') { |f|
    abort "Can't find config file: #{f}." unless File.readable?(f)

    options[:config] = f
  }

  opts.separator ''

  opts.on('-t', '--threshold NUM', Float, "Similarity threshold [Default: #{options[:threshold]}]") { |t|
    options[:threshold] = t
  }

  opts.on('-m', '--minimal', 'Produce minimal pairs only') {
    options[:minimal] = true
  }

  opts.on('-s', '--sort', 'Sort results (considerably slower!)') {
    options[:sort] = true
  }

  opts.on('-l', '--lingo', 'Output results in lingo dictionary format') {
    options[:lingo] = true
  }

  opts.on('-S', '--stats', 'Output some statistics at the end') {
    options[:stats] = true
  }

  opts.separator ''
  opts.separator '  * Checking pairs'
  opts.separator ''

  opts.on('-C', '--check', 'Check pairs in input file (CSV) against', 'specified (or global) threshold') {
    options[:check] = true
  }

  opts.on('-f', '--failed', 'Print only failed checks') {
    options[:failed_only] = true
  }

  opts.on('-a', '--align', 'Align check results') {
    options[:align] = true
  }

  opts.separator ''
  opts.separator 'Generic options:'

  opts.on('-h', '--help', 'Print this help message and exit') {
    abort opts.to_s
  }

  opts.on('--version', 'Print program version and exit') {
    abort "#{File.basename($0)} v#{PerseusMatch::VERSION}"
  }
}.parse!

unless file = ARGV.shift
  abort "No input file specified.\n#{USAGE}"
else
  abort "Input file not found: #{file}" unless File.readable?(file)
end

PerseusMatch::TokenSet.tokenize(file)

skip_re = %r{\A\s*(?:#|\z)}o
phrases = File.readlines(file).map { |line| line.chomp unless line =~ skip_re }.compact

pm_options = options[:config] ? YAML.load_file(options[:config]) : {}
list_options = { :minimal => options[:minimal] }

threshold, count, count_all = options[:threshold], 0, 0

action = if options[:check]
  require 'fastercsv'

  if options[:align]
    width  = phrases.max(:jlength) + 3
    format = lambda { |line, res|
      "#{line} #{'.' * (width - line.jlength)} [#{res}]"
    }
  else
    format = lambda { |line, res|
      "#{line} [#{res}]"
    }
  end

  phrases.sort! if options[:sort]
  phrases.map! { |line| [line, FasterCSV.parse_line(line)] }

  global_threshold = options[:threshold]
  failed_only      = options[:failed_only]

  lambda {
    phrases.each { |line, spec|
      phrase, target, threshold, operator, _ = *spec

      threshold ||= global_threshold
      operator  ||= :>

      begin
        PerseusMatch.check!(phrase, target, threshold.to_f, operator, pm_options)
        count += 1
        puts format[line, 'OK'] unless failed_only
      rescue PerseusMatch::CheckFailedError => err
        puts format[line, "FAILED -- #{err.value}"]
      end
      count_all += 1
    }
  }
else
  format =
    options[:lingo] ? lambda { |pm| "#{pm.phrase}*#{pm.target}" } :
    options[:sort]  ? lambda { |pm| [pm.target, pm.distance, pm.similarity] } :
                      lambda { |pm| [pm.phrase, pm.target, pm.distance, pm.similarity].inspect }

  if options[:sort]
    require 'pp'

    lambda {
      pp PerseusMatch::Cluster.new(phrases, pm_options, list_options).sort { |pm|
        if pm.similarity >= threshold
          res = format[pm]
          count += 1
        end
        count_all += 1
        res
      }.map { |i| i.map { |j| j.is_a?(Array) ? j.compact : j } }
    }
  else
    lambda {
      PerseusMatch::List.pair(phrases, pm_options, list_options) { |pm|
        if pm.similarity >= threshold
          puts format[pm]
          count += 1
        end
        count_all += 1
      }
    }
  end
end

if options[:stats]
  time = Benchmark.realtime(&action)

  hms, x, y = time.to_hms(2), time / count, time / count_all

  precision = lambda { |i| i.to_s.sub(/\./, '')[/\A0*/].length + 2 }

  warn "%d (%d/%d): %s => %0.#{precision[x]}fs/%0.#{precision[y]}fs" % [
    phrases.size, count, count_all, hms, x, y
  ]
else
  action.call
end
