#! /usr/bin/ruby

require 'optparse'
require 'benchmark'
require 'yaml'

require 'rubygems'
require 'nuggets/numeric/duration'

$: << File.join(File.dirname(__FILE__), '..', 'lib')

require 'perseus_match'

USAGE = "Usage: #{$0} [-h|--help] [options] <file>"
abort USAGE if ARGV.empty?

options = {
  :config    => nil,
  :threshold => 0,
  :sort      => false,
  :stats     => false,
  :check     => false
}

OptionParser.new { |opts|
  opts.banner = USAGE

  opts.separator ''
  opts.separator 'Options:'

  opts.on('-c', '--config YAML', 'Config file in YAML format') { |f|
    abort "Can't find config file: #{f}." unless File.readable?(f)

    options[:config] = f
  }

  opts.separator ''

  opts.on('-t', '--threshold NUM', Float, "Similarity threshold [Default: #{options[:threshold]}]") { |t|
    options[:threshold] = t
  }

  opts.on('-s', '--sort', 'Sort results (considerably slower!)') {
    options[:sort] = true
  }

  opts.on('--stats', 'Output some statistics at the end') {
    options[:stats] = true
  }

  opts.separator ''

  opts.on('--check', 'Check pairs in input file (CSV) against', 'specified (or global) threshold') {
    options[:check] = true
  }

  opts.separator ''
  opts.separator 'Generic options:'

  opts.on('-h', '--help', 'Print this help message and exit') {
    abort opts.to_s
  }

  opts.on('--version', 'Print program version and exit') {
    abort "#{File.basename($0)} v#{PerseusMatch::VERSION}"
  }
}.parse!

unless file = ARGV.shift
  abort "No input file specified.\n#{USAGE}"
else
  abort "Input file not found: #{file}" unless File.readable?(file)
end

PerseusMatch::TokenSet.tokenize(file)

skip_re = %r{\A\s*(?:#|\z)}o
phrases = File.readlines(file).map { |line| line.chomp unless line =~ skip_re }.compact

pm_options = {}
pm_options[:distance_spec] = YAML.load_file(options[:config]) if options[:config]

threshold, count, count_all = options[:threshold], 0, 0

action = if options[:check]
  require 'fastercsv'

  phrases.sort! if options[:sort]
  phrases.map! { |line| [line, FasterCSV.parse_line(line)] }

  lambda {
    phrases.each { |line, spec|
      phrase, target, threshold, operator, _ = *spec

      threshold ||= options[:threshold]
      operator  ||= :>

      res = begin
        PerseusMatch.check!(phrase, target, threshold.to_f, operator, pm_options)
        count += 1
        'OK'
      rescue PerseusMatch::CheckFailedError => err
        "FAILED -- #{err.value}"
      end
      count_all += 1

      puts "#{line} [#{res}]"
    }
  }
else
  if options[:sort]
    lambda {
      require 'pp'

      pp PerseusMatch::Cluster.new(phrases, pm_options).sort { |pm|
        if pm.similarity >= threshold
          [pm.target, pm.distance, pm.similarity]
          count += 1
        end
        count_all += 1
      }.compact
    }
  else
    lambda {
      PerseusMatch::List.pair(phrases, pm_options) { |pm|
        if pm.similarity >= threshold
          p [pm.phrase, pm.target, pm.distance, pm.similarity]
          count += 1
        end
        count_all += 1
      }
    }
  end
end

if options[:stats]
  time = Benchmark.realtime(&action)

  hms, x, y = time.to_hms(2), time / count, time / count_all

  precision = lambda { |i| i.to_s.sub(/\./, '')[/\A0*/].length + 2 }

  warn "%d (%d/%d): %s => %0.#{precision[x]}fs/%0.#{precision[y]}fs" % [
    phrases.size, count, count_all, hms, x, y
  ]
else
  action.call
end
