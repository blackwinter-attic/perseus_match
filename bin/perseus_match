#! /usr/bin/ruby

require 'optparse'
require 'benchmark'

require 'rubygems'
require 'nuggets/numeric/duration'

$: << File.join(File.dirname(__FILE__), '..', 'lib')

require 'perseus_match'

USAGE = "Usage: #{$0} [-h|--help] [options] <file>"
abort USAGE if ARGV.empty?

options = {
  :stats     => false,
  :threshold => 0,
  :sort      => false
}

OptionParser.new { |opts|
  opts.banner = USAGE

  opts.separator ''
  opts.separator 'Options:'

  opts.on('--stats', 'Output some statistics at the end') {
    options[:stats] = true
  }

  opts.on('-t', '--threshold NUM', Float, "Similarity threshold [Default: #{options[:threshold]}]") { |t|
    options[:threshold] = t
  }

  opts.on('-s', '--sort', 'Sort results (considerably slower!)') {
    options[:sort] = true
  }

  opts.separator ''
  opts.separator 'Generic options:'

  opts.on('-h', '--help', 'Print this help message and exit') {
    abort opts.to_s
  }

  opts.on('--version', 'Print program version and exit') {
    abort "#{File.basename($0)} v#{PerseusMatch::VERSION}"
  }
}.parse!

unless file = ARGV.shift
  abort "No input file specified.\n#{USAGE}"
else
  abort "Input file not found: #{file}" unless File.readable?(file)
end

PerseusMatch::TokenSet.tokenize(file)

phrases = File.readlines(file).map { |line| line.chomp }

threshold, count, count_all = options[:threshold], 0, 0

time = Benchmark.realtime {
  if options[:sort]
    require 'pp'

    pp PerseusMatch::Cluster.new(phrases).sort { |pm|
      if pm.similarity >= threshold
        [pm.target, pm.distance, pm.similarity]
        count += 1
      end
      count_all += 1
    }.compact
  else
    PerseusMatch::List.pair(phrases) { |pm|
      if pm.similarity >= threshold
        p [pm.phrase, pm.target, pm.distance, pm.similarity]
        count += 1
      end
      count_all += 1
    }
  end
}

if options[:stats]
  hms, x, y = time.to_hms(2), time / count, time / count_all

  precision = lambda { |i| i.to_s.sub(/\./, '')[/\A0*/].length + 2 }

  warn "%d (%d/%d): %s => %0.#{precision[x]}fs/%0.#{precision[y]}fs" % [
    phrases.size, count, count_all, hms, x, y
  ]
end
